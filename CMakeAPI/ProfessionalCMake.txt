##############################################################################################################################
#此文件脱胎自Professional Cmake一书，表述各个函数以及各个参数的基本用法
#
#
#
##############################################################################################################################





##############################################################################################################################
设置normal Variable, 该变量仅仅会在CMakeLists中生效
#变量无需再使用之前进行声明，为声明的变量进行使用不会报错，会以空字符串进行代替
#不带空格的名称无需用引号扩起，如果出现多个value那么中间的空格将会变成“；”
#PARENT_SCOPE----->假设CMakeList.tx为多层级的（里面存在add_subdirectory（）..）, 使用PARENT_SCOPE即在其父scope定义varname且名称为value，如果父scope已经存在该varname则修改父scope的内容
set(varname value...[PARENT_SCOPE]) 
# 这种set variable 的方式仅仅只在当前的CMakeLists中生效
# set(USER hello)
# #在[[]]或者[=...[ ]=...]之中包裹的对象不会再进行substitution以及escaping, 简单理解就是-----原样输出
 set(a [[ 
 "${USER} World...."
 ]]
 )#输出   "${USER} World...."
# set(b "\"${USER} World....\"") #没有包裹在[[表达式之中引号需要加入\号，同时变量会进行替换  输出"hello World...."
##############################################################################################################################
 设置cache variable ，该变量会放置在CMakeCache中，整个build过程都会生效
 set(varName value... CACHE type "docstring" [FORCE])
# CACHE 关键字代表生成CACHEVARIABLE
# type和docstring仅仅是用来给CMAKE-GUI的提示标记,docstring是鼠标悬浮其上的提示
 option(optvar helpstring [initialValue])  等价于set(optvar initialValue CACHE BOOL helpstring)但是更加的清晰和直接
# 注意:倘若normal Variable 和 Cache Variable存在同名变量，那么在时候第一次会显示Cache第二次以后会使用normal
#set(trafficLight Green CACHE STRING "Status of something")
mark_as_advanced(CLEAR trafficLight) #gui仅会显示no-advance变量 clear表达no-advance，FORCE代表Advance
#set_property(CACHE trafficLight PROPERTY STRINGS Red Orange Green) #更改gui上的显示
########################################################################################################################################
查找字符串 string(FIND inputString subString outVar [REVERSE]) 
#set(longstr adcdefabcdef)
#set(shortbit def)
#string(FIND ${longstr} ${shortbit} fwdindex)
string(FIND ${longstr} ${shortbit} revindex REVERSE)
#message("fwdindex = ${fwdindex}, revindex = ${revindex}"    #输出fwdindex = 3,revIndex=9
替换字符串 string(REPLACE matchString replaceWith outVar input [intput....]) #注意多个input输入系统会将其利用没有分隔符的记号连接起来在做替换，这样的作法可能造成意想不到的后果，故建议不要多个input一起输入
string(REPLACE c YES output ${longstr}) #输出abYESDEFABYESdef 
正则字符串查找
string(REGEX MATHCH regex outVar input [input...]) #查找input中第一个匹配(regex规则)并且存在outVAr中
string(REGEX MATCHALL regex outVar input [input...]) #查找input中所有的匹配(regex规则)并且以列表的形式存在outVAr中
string(REGEX REPLACE regex replaceWith outVar input [intput...])
#ex: set(longstr adcdefabcdef)
#ex：string(REGEX MATCHCALL "[ace]" matchVar ${longstr}) #输出： a;c;e;a;c;e x
#ex：string(REGEX REPLACE "([de])" [[x\1Y]] replVar ${longstr}) #abcXdYXeYfabcXdYXeYf
提取子字符串
string(SUBSTRING input index length outVar) #在input中从index起提取length长度的字符串存入outVar中 （length= -1 则提取后面所有）
-----
string(LENGTH input outVar)       #获取字符串长度
string(TOLOWER input outVar)      #转换为小写        
string(TOUPPER input outVar)      #转换为大写
string(STRIP input outVar)        #左右两边移除空
#还包含字符比较，哈希，时间撮等操作--->用的较少，阅读文档
################################################################################################################################################################################
Lists 列表   ---------------列表就是一串被分号将item分隔的字符串
#第一个参数代表需要操作的类型， 第二个参数代表需要操作的对象（必修是变量）
#所有传入索引均可以为负值，代表从后往前的索引
List(LENGTH listVar outVar)                 #获取列表长度
list(GET listVar index [index...] outVar)   #获取固定索引的内容
list(APPEND listVar item [item...])         #将item append到list的末尾
list(INSERT listVar index item [item...])   #将item insert到list的index处
list(FIND mylist value outVar)              #找到mylist中的匹配value的项，并返回outVAr（索引）
list(REMOVE_ITEM myList value [value...])   #将value从mylist中移除
list(REMOVE_AT myList index [index...])     #将value处于index索引中的内容移除
list(REMOVE_DIPLICATES myList)              #祛除重复项目
list(REVERSE mylist)                        #反向排列list
list(SORT myList)                           #排序（依照alphabetical）

# Example
# set(myList a b c)              #creates the list "a;b;c"
# list(LENGTH myList len)        #len = 3
# list(GET myList 2 1 letters)   #c;b
#
############################################################################################
math 操作
math(EXPR outVar mathExpr) ---EXPR(必加参数)，outvar--输出数值   mathExpr----数学表达式
#   set(x 3)
#   set(y 7)
#   math(EXPR z "(${x} + ${y}) / 2")   #z = 5
############################################################################################
Logic Operations
if(NOT expression)
if(expression1 AND expression2)
if(expression1 OR expression2)
#ex: if(NOT (expression1 AND (expression2 OR expression3)))
comparison test 
if(value1 OPERATOR value2) #OPERATOR 可以为LESS GREATER.....等等，分为numeric， string， version三类，具体查表
正则匹配
if(value MATCHES regex) #匹配成功的项目将会存于CMAKE_MATCH_<n>中，其中0是整个匹配的字符串
# ex: if("Hi from ${who}" MATCHES "Hi from (Fred|Barney).*)
#          message("${CMAKE_MATCH_1} says hello")
#     endif()
FileSystem Tests 
#if(EXISTS pathToFileOrDir) #
#if(IS_DIRECTORY pathToDir)
#if(IS_SYMLINK fileName)
#if(IS_ABSOLUTE path)
#if(file1 IS_NEWER_THAN file2)
Existence Tests 
if(DEFINED name)   #检查name是否存在，存在返回true
#ex:if(DEFINED SOMEVAR)          #checks for a CMake variable
#   if(DEFINED ENV{SOMEVAR})     #checks for an environmental variable
if(COMMAND name)                #checks for CMake command,function,macro with specified name exists
if(POLICY name)                 #checks for whether a particular policy is known to cmake
if(TARGET name)                 #checks for Cmake target exists (defined by add_excutable,add_libray..)
if(TEST name)                   #check for name whether is defined by the command add_test()
#############
foreach 循环
foreach(loopvar RANGE start stop [step])
foreach(loopvar range value) #等价于foreach(loopvar RANGE 0 value)
foreach(loopvar IN [LISTS listVar1 ...] [ITEMS item1 ...])
    #....
endforeach() 
#set(list1 A B C D)
#set(list2)                            #允许为空
#set(list3 E F G)
#set(foo willonbeshown)
#foreach(loopvar IN LISTS list1 list2 list3 ITEMS foo bar) #对item
#   message("Iteration for: ${loopvar}") 
#endforeach()
##############################################################################################################################################################################################################
while 循环
while(condition)
    #...
endwhile()
跳出循环
break()
continue()
#############################################################################################################################################################################################################
#add_subdirectory()会开辟一个child scope这个scope有如下特点（调用add_subdirector()的CMakeList.txt的空间称为calling scope， 其指向的空间成为child_scope)
# 1.定义在calling scope空间中的变量在子空间中均可见。
# 2.child scope中定义的*变量*（与target区分开来）在calling scope中不可见
# 3.任何在child scope中的变化仅仅只在该子空间中有效。
# 4.child scope与calling scope property在正常情况下互不干扰
add_subdirectory(sourceDir [binaryDir] [EXLUDE_FROM_ALL]) #将另外一个dir导入build之中，该build必须有自己的CMakelist.txt
############################################################################################################################################################################################################
#include()与add_subdirectory()相似，但有如下不同
# 1.include()输入的是一个filename(一般情况带.cmake后缀,但其可以为任何数据)而不是dir
# 2.include()不会产生新的variable scope
# 3.include() 和 add_sub_directory()都会引入新的policy scope, 但是include可以通过给如NO_POLITY_SCOPE选项去禁止产生新的polity scope，add_subdirectory()无法做到这一点
# 4.CMAKE_CURRENT_SOURCE_DIR和CMAKE_CURRENT_BINARY_DIR 在include()函数使用时不会改变。而add_subdirectory()会
# 针对第四个属性产生的问题，CMAKE给出了三个新的变量去解决，分别为CMAKE_CURRENT_LIST_DIR、CMAKE_CURRENT_LIST_FILE、CMAKE_CURRENT_LIST_LINE
include(fileName [OPTIONAL] [RESULT_VARIABLE myVar] [NO_POLITY_SCOPE])
include(module [OPTIONAL] [RESULT_VARIABLE myVar] [NO_POLITY_SCOPE])
##########################################################################################################################################################################################################
return() #跳出处理scope，并不能返回值仅仅是将当前的处理scope结束
##########################################################################################################################################
函数与宏
function(name [arg1 [arg2 [...]]])
    #Function body(i.e. commands)....
endfunction()

macro(name [arg1 [arg2 [...]]])
    #Macro body(i.e commands).....
endmacro()

 